Starting code feedback for Cherie, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 6.68 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, week3, week2, Feedback, week1

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
 
# Gitignore files and directory
*.DS_Store
week1/code/.*
week1/sandbox/*
!week1/sandbox/.gitkeep
week2/sandbox/*
!week2/sandbox/.gitkeep
week3/sandbox/*
!week3/sandbox/.gitkeep
week4/sandbox/*
!week4/sandbox/.gitkeep
week2/code/__*




**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# *My CMEE Coursework Repository*

## General Description
This repository contains my coursework for the Computational Methods of Ecology and Evolution Course (CMEE) at Imperial College. 

All codes in this project was written and tested in R and Python3. Based on the **The Multilingual Quantitative Biologist** [online book](https://mhasoba.github.io/TheMulQuaBio/intro.html). 

***
## Usage
If you would like to use and download my repository, please *clone* this and move it to your our directory. 

***
## Project Structure 
The repository is organised in week structures. Within each week contains the core directories: 
*code*, *data*, *results*, *sandbox*

    - Week1: Unix/Linux, Bash Shell Scripting and LaTeX
    - Week2: Biological Computing with Python I

***
## Note
Note that these codes are all written on a MacOS, therefore there might be minimal differences in the use of syntax, however in general it would run in any operating systems. 

Author: Cherie Yu
Contact: cyy21@ic.ac.uk
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: code, sandbox, results, data

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# *Week 2*


## General Description

Biological Computing in Python I - This week focuses on the use of Python programming language to write codes, scripts, programs and packages.

***

## Languages
Python 3.

***
## Dependencies
ipython3

***
## Installation

Use the package manager [homebrew] (https://brew.sh/) to install ipython3.

```bash
brew install ipython
```

***
## Project Structure and Usage

../code

    - loops.py : Example code of For loops
    - cfexercises1.py : Python code using conditionals
    - cfexercises2.py : Python code using a combination of loops and conditionals
    - oaks.py : Use of list comprehensions to undergo a task on finding oak species]
    - scope.py : Understanding variable scope through global and local variables
    - basic_io*.py : Python input/output scripts
    - basic_csv.py : Importing and handling .csv in python
    - boilerplate.py : Boilerplate exemplyfing components of a python program
    - using_name.py : Using name to import a module
    - control_flow.py : Python program using various control flow tools
    - Comprehension Practicals
            1. lc1.py
            2. lc2.py
            3. tuple.py
            4. dictionary.py
    - test_control_flow.py : Embedding unit testing with doctest in program
    - debugme.py : Example script for debugging
    - align_seqs.py : Practical editing a python program to align DNA sequences
    - oaks_debugme.py : Practical using debugging methods to modify script


Author: Cherie Yu
Contact: cyy21@ic.ac.uk

**********************************************************************

Found following files in results directory: best_alignment.txt...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 99.5

Found 22 code files: scope.py, debugme.py, lc2.py, control_flow.py, loops.py, basic_io3.py, align_seq.py, cfexercises1.py, oaks.py, using_name.py, dictionary.py, test_control_flow.py, sysargv.py, tuple.py, cfexercises2.py, basic_io1.py, basic_io2.py, boilerplate.py, MyExampleScript.py, lc1.py, basic_csv.py, oaks_debugme.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file scope.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
#Local variables and global variables
#############################
#Local variables and explicitly returning function to show inside and outside function

_a_global = 10 #global variable

if _a_global >= 5: #global variable, if a_global is equal or bigger than 5, go to this loop
    _b_global = _a_global + 5

def a_function(): # Defining a new function
    _a_global = 5 # local variable, we overwritten a_global with 5 instead of 10 but it stayed inside this function

    if _a_global >= 5: # if a is bigger or equal to 5 which it is
        _b_global = _a_global + 5 # b = 10
    
    _a_local = 4 

    print("Inside the function, the value of _a_global is ", _a_global) #prints 5
    print("Inside the function, the value of _b_global is ", _b_global) #prints 10
    print("Inside the function, the value of _a_local is ", _a_local) #prints 4
    
    return None # good practice to add this just like adding exit in bash. 

a_function() # explicitly return the function to make it visible outside function, prints out the function which is the three line inside the function

print("Outside the function, the value of _a_global is ", _a_global) # prints 10 from first if statement
print("Outside the function, the value of _b_global is ", _b_global) # prints 15 from the first if statements

#BUT if you assign a variable outside the function, it will still be available inside the function, not the other way around

#################
#Global Variables
#################

_a_global = 10

print("Outside the function, the value of _a_global is", _a_global) # a global = 10

def a_function():
    global _a_global #global variable from inside a function 
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global) # a global = 5
    print("Inside the function, the value _a_local is ", _a_local) # a local = 4
    
    return None

a_function() # print the above two lines (print)

print("Outside the function, the value of _a_global now is", _a_global) # a global = 5 , the a is replaced/overwritten by the global value inside the function

#Global variables can also be Inside Nested Functions
def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20 # global keyword inside the inner function resulted in change of value in a global to 20 but only outside of the scope of the function
    
    print("Before calling a_function, value of _a_global is ", _a_global) # still 10

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global) # still 10
    
    return None

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global) # a global is the global variable 20 
# within the scrope of a function, the value of a still remained at 10 but only in the outside function is when the a global has changed due to line 59

#Example 2 
_a_global = 10 # The main difference from the one above , defined in advanced

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function, value of _a_global is ", _a_global) # a is 10

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global) # a is 20 WHY IS THIS 20 

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global) # a is 20
**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more functions, but completely missing docstrings
2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function

Current Points = 94.5

Output (only first 500 characters): 


**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15
Outside the function, the value of _a_global is 10
Inside the function, the value of _a_global is  5
Inside the function, the value _a_local is  4
Outside the function, the value of _a_global now is 5
Before calling a_function, value of _a_global 
**********************************************************************

Code ran without errors

Time consumed = 0.07749s

======================================================================
Inspecting script file debugme.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Debugging Funtion
##################

def buggyfunc(x):
    y = x
    for i in range(x):
        try: #tries to do something and if it doesnt work (error) transfer control to the except block 
        #and whatever you ask python to do in that block get executed. 
        #use this if you want the program to give feedback in errors that are not common
            y = y-1
            z = x/y
        except:
            print(f"This didn't work; x = {x}; y = {y}")
        else:
            print(f"OK: x = {x}; y = {y}, z = {z};")
    return z

buggyfunc(20)


**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more functions, but completely missing docstrings
2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function

Current Points = 92.0

Output (only first 500 characters): 


**********************************************************************
OK: x = 20; y = 19, z = 1.0526315789473684;
OK: x = 20; y = 18, z = 1.1111111111111112;
OK: x = 20; y = 17, z = 1.1764705882352942;
OK: x = 20; y = 16, z = 1.25;
OK: x = 20; y = 15, z = 1.3333333333333333;
OK: x = 20; y = 14, z = 1.4285714285714286;
OK: x = 20; y = 13, z = 1.5384615384615385;
OK: x = 20; y = 12, z = 1.6666666666666667;
OK: x = 20; y = 11, z = 1.8181818181818181;
OK: x = 20; y = 10, z = 2.0;
OK: x = 20; y = 9, z = 2.2222222222222223;
OK: x = 20; y = 8, z = 2.5;
OK: x = 20; y = 7, 
**********************************************************************

Code ran without errors

Time consumed = 0.07738s

======================================================================
Inspecting script file lc2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Practical Comprehensions
##################

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

rain = [i for i in rainfall if i[1]>100]
print(rain)

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

month = [a[0] for a in rainfall if a[1]<50]
print(month)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

#(1)
rain = []
for i in rainfall:
    if i[1]>100:
        rain.append(i)
print(rain)

#(2)
month = []
for a in rainfall:
    if a[1]<50:
        month.append(a[0])
print(month)


**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 90.0

Output (only first 500 characters): 


**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.07749s

======================================================================
Inspecting script file control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
#CONTROL FLOW
#############################

"""Some functions exemplifying the use of control statements""" #Docstring
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Cherie Yu (cy221@ic.ac.uk)'
__version__ = '0.0.1'

## imports ##
import sys #module to interface our program with the operating system

## functions ##

def even_or_odd(x=0): # if not specified, x should take value 0.
   
    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if 
        return "%d is Even!" % x # % x at the end is used to tell %d, a placeholder what it is and to sub
    return "%d is Odd!" % x

def largest_divisor_five(x=120): # if z is not specified , x will be 120 
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if,elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable
    return "The largest divisor of %d is %d" % (x,largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2,x): # "range" returns a squence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x,i))
            return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):  # Step 2
    print(even_or_odd(22)) # Loop 1 to the top
    print(even_or_odd(33)) # Loop 2 to the top 
    print(largest_divisor_five(120)) # Loop3 to the top
    print(largest_divisor_five(121)) #Loop 4
    print(is_prime(60)) #Loop 5
    print(is_prime(59)) #Loop 6
    print(find_all_primes(100)) #Loop 7
    return 0

if (__name__ == "__main__"): # Step 1
    status = main(sys.argv) 
    sys.exit(status) 






**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 89.5

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.07864s

======================================================================
Inspecting script file loops.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# FOR loops in Python
#############################

for i in range(5):
    print(i)

my_list = [0, 2, "geronimo", 3.0, True, False]
for k in my_list: #naming k as a variable and subing it with my_list 
    print(k) 

total = 0 
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s #this loop continues on and replaces the previous loop total with the new total 
    print(total)

# WHILE loops in python
z = 0
while z < 100:
    z = z + 1 #prints out all the numbers to 100, this loop replaces the last z with the new z 
    print(z)

b = True #True keeps printing
while b:
        print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!
**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 87.5

Output (only first 500 characters): 


**********************************************************************
0
1
2
3
4
0
2
geronimo
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c 
**********************************************************************

Code ran without errors

Time consumed = 11.66191s

======================================================================
Inspecting script file basic_io3.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11} #set a new variable
print(my_dictionary)

import pickle 

f = open('../sandbox/testp.p','wb') #w tells to open a file for writing, b tells to accept binary files 
pickle.dump(my_dictionary, f) #using pickled save my dictionary into f (testp.p)

f.close()

## Load the data again
f= open('../sandbox/testp.p','rb') #opening back file
another_dictionary = pickle.load(f) #open pack f into a human readable file 
f.close()

print(another_dictionary)

**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 85.5

Output (only first 500 characters): 


**********************************************************************
{'a key': 10, 'another key': 11}
{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.13982s

======================================================================
Inspecting script file align_seq.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Align DNA Sequence Practical 
##################


"""Python program that aligns two DNA sequences and calculates the best alignment score"""

__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## Imports ##
import sys # module to interface our program with the operating system

# Import input code file 
with open('../data/testalign.txt', 'r') as f:
    """Opening input file and assigning variables to each sequence"""
    lines = []
    for line in f:
        lines.append(line.strip())
    print(lines)
    
seq1 = lines[0]
seq2 = lines[1]
print(seq1)
print(seq2)

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

## Functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is the best alignment score between the two sequences') # NOTE: indented using two tabs or 4 spaces
    return 0

#Positioning the longer sequence on top
l1 = len(seq1) # Count the length of the sequences, In this example, l2 is longer than l1
l2 = len(seq2)
print(l1) #10
print(l2) #16
if l1 >= l2: # if l1 is longer than l2
    s1 = seq1 #longer sequence
    s2 = seq2 #shorter sequence
else:
    s1 = seq2 #16
    s2 = seq1 #10
    print(s1) 
    print(s2)
    l1, l2 = l2, l1 # swap the two lengths
print(l1)
print(l2)
print(s1) # equals to seq2
print(s2) # equals to seq1

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """calculate alignment score"""
    matched = "" # to hold string displaying alignements
    score = 0 
    for i in range(l2): #Starting from base 0 to base 9, l2 is the shorter sequence e.g 10, 
        #import ipdb; ipdb.set_trace()
        if (i + startpoint) < l1: # If the end of the sequence hasnt been reached, then starting from the startpoint + i (rangel2), count the number of bases
            if s1[i + startpoint] == s2[i]: # if the bases match 
                matched = matched + "*" # add a star to the  matched 
                score = score + 1 # and add a score point 
            else:
                matched = matched + "-" #if the bases don't matched 

    # some formatted output
    print("." * startpoint + matched) #print out matched score (- and *) 
    # "." is saying to multiply with the number of startpoint to start e.g startpoint = 0, multiplt "."" x 0 = 0 so start the signs at the beginning  
    print("." * startpoint + s2) #print out the s2 from the startpoint, just like the above
    print(s1) #longer sequenece
    print(score) 
    print(" ")

    return score #end the code with a score 

# Test the function with some example starting points:
calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1) # code starts on the 2nd
calculate_score(s1, s2, l1, l2, 5) # code starts on the 6th

# now try to find the best match (highest score) for the two sequences, find the sequence with the highest alignment 
my_best_align = None #null value or no value 
my_best_score = -1 #why -1 because best score can be 0

for i in range(l1): # Note that you just take the last alignment with the highest score, l1 = 16
    """Calculate the highest alignment score"""
    #import ipdb; ipdb.set_trace()
    z = calculate_score(s1, s2, l1, l2, i) #the score of alignment from above function
    if z > my_best_score: #if alignment score is higher than the best score 
        my_best_align = "." * i + s2 # think about what this is doing!
        # "." multiplied by the starting point + shorter sequence
        my_best_score = z # best score = calculated score per i in range, as it the short sequence moves one base to the right acording to the longer sequence
print(my_best_align) #the best alignment which is in startingpoint 0
print(s1) #the longer sequence
print("Best score:", my_best_score)

##File Output##
lines=[my_best_align, s1, "Best score:"+ str(my_best_score)]
with open('../results/best_alignment.txt', 'w' ) as b: 
    for line in lines:
        b.write(line)
        b.write('\n')
print("Best alignment saved to result folder")

# it shows the highest best score because it goes from z = calculated score then if z > my_best_score will replace the best score 
#and when it loops it keeps changing my best score with the largest value (line 63 and 66)
if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing align_seq.py...

align_seq.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 85.5

Output (only first 500 characters): 


**********************************************************************
['ATCGCCGGATTACGGG', 'CAATTCGGAT']
ATCGCCGGATTACGGG
CAATTCGGAT
16
10
16
10
ATCGCCGGATTACGGG
CAATTCGGAT
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2
 
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5
 
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2
 
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1
 
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1
 
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1
 
.....*---*-----
.....C
**********************************************************************

Code ran without errors

Time consumed = 0.08008s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# USE OF CONDITIONALS IN FUNCTIONS
#############################

## imports ##
import sys 
import doctest

## functions ##

def foo_1(x): 
    """Takes in x and returns x to the power of 0.5""" #Docstring
    return x ** 0.5 #for foo_1, return x a power of 0.5

def foo_2(x,y):
    """Compares x and y, and print out x or y depending on which is bigger"""
    if x > y: 
        return x #if x is bigger than y, print out x and leave command
    return y #if y is bigger, print out y and leave command
#RETURN= An exit command, if the condition is met, it will jump out of the function without touching the bottom commands unlike print

def foo_3(x,y,z): #Switching places of numbers
    """if x is bigger than y, switch the places of x and y using a placeholder""" 
    """if y is bigger than z, switch the places of y and z using a placeholder"""
    if x > y: 
        tmp = y #temporary placeholder file to store y value
        y = x # y is now the x value
        x = tmp #x is now the value in the tmp placeholder 
    if y > z:
        tmp = z #z value is in the temporary placehold
        z = y #z is y value
        y = tmp #y is the value in the temporary placeholder
    return [x,y,z]

def foo_4(x):
    """Using the values between the range 1 to x+1, function loops between each value and replaces the result of the previous loop"""
    """keeps looping until it reaches the end value"""
    result = 1
    for i in range(1, x + 1): 
        result = result * i #keeps looping until it reached x+1, and replaces the result of the previous loop
        print(result)
    return result

def foo_5(x): # a recursive (calls itself) function that calculates the factorial of x
    """ if x is 1, return the output as 1"""
    """ if x is not 1, then produce a factorial of x and return""" 
    if x == 1:  #if x = 1 return 1
        return 1
    return x * foo_5(x-1) #equation to produce a factorial of x 
#factorial e.g 5! = 5x4x3x2x1 

def foo_6(x): # Calculate the factorial of x in a different way
    """while x is bigger than 1 then """
    """if x is less than 0, undergo command and replace x with a new value and repeats the loop"""
    facto = 1
    while x >= 1: #while statements execute a set of command as long as the condition is true 
        facto = facto * x 
        x = x - 1
        print(x)
    return facto 

def main(argv):  # Step 2
    print(foo_1(11)) # Loop 1 to the top
    print(foo_1(9)) # Loop 2 to the top 
    print(foo_2(4,3)) # Loop3 to the top
    print(foo_2(5,8)) #Loop 4
    print(foo_3(4,3,2)) #Loop 5
    print(foo_3(1,5,4)) 
    print(foo_4(5)) #Loop 6
    print(foo_5(10)) #Loop 7
    return 0

if (__name__ == "__main__"): # Step 1
    status = main(sys.argv) 
    sys.exit(status) 

doctest.testmod() 


**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 85.5

Output (only first 500 characters): 


**********************************************************************
3.3166247903554
3.0
4
8
[3, 2, 4]
[1, 4, 5]
1
2
6
24
120
120
3628800

**********************************************************************

Code ran without errors

Time consumed = 0.11715s

======================================================================
Inspecting script file oaks.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
## Finds just those taxa that are oak trees from a list of species
#############################

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name): # a function = true or falste statement, define is_an_oak, replace name with the name of the taxa
    return name.lower().startswith('quercus') #make name lower case and if starts with quercus = TRUE (it is an oak)

##Using for loops to make a set
oaks_loops = set() #new set called oaks_loops
for species in taxa: 
    if is_an_oak(species): #if it is an oak species like from above function
        oaks_loops.add(species) #add it into the set called oak loop
print(oaks_loops) #gets a set of oak tree 

##Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)]) #list compregension method for above loop 
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set() 
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper()) #add it into oaks_loops in uppercase
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)]) #Comprehension form of the above loop. uppercase first in the bracket 
print(oaks_lc) 
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more functions, but completely missing docstrings
2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function

Current Points = 83.0

Output (only first 500 characters): 


**********************************************************************
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'QUERCUS CERRIS', 'QUERCUS ROBUR', 'QUERCUS PETRAEA'}
{'QUERCUS CERRIS', 'QUERCUS ROBUR', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.08351s

======================================================================
Inspecting script file using_name.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
#IMPORT TESTING WITH ANOTHER MODULE
#############################
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')

print("This module's name is: " + __name__)
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 81.0

Output (only first 500 characters): 


**********************************************************************
This program is being run by itself
This module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.07892s

======================================================================
Inspecting script file dictionary.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Practical Comprehensions using Dictionary
##################

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa.
# 
# An example output is:
#  
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc.
#  OR,
# 'Chiroptera': {'Myotis lucifugus'} ... etc

#Chiroptera, Carnivora, Afrosoricida, Rodentia
#{} creates an empty dictionary

newlist = {} #When you do dictionary {} means that already
for spp, fam in taxa: # for x,y in the list
    newlist.setdefault(fam, []).append(spp) #setdefault() searches for a key and displays the value. 
    #but if that value is not present, it will create a new key
    #It loops through taxa, gets the first one, takes fam = y puts it in the front, and then puts species into []
    #without append spp, the [] will be blank 
    #put nothing inside [] to show no key, so the value in spp will become that new value
    #dictioinary prevents repeating as well so the same family won't be repeated 
print(newlist)


**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 79.0

Output (only first 500 characters): 


**********************************************************************
{'Chiroptera': ['Myotis lucifugus'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus']}

**********************************************************************

Code ran without errors

Time consumed = 0.07782s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Control Flow Debugging with DocTest
##################

"""Description of this program or application. 
You can use several lines""" #Docstring

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__author__ = 'Cherie Yu (cy221@ic.ac.uk)'
__version__ = '0.0.1'

## imports ##
import sys #module to interface our program with the operating system
import doctest #Import the doctest module

## functions ##

def even_or_odd(x=0): # if not specified, x should take value 0.
    """Find whether a number x is even or odd.

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:
    >>> even_or_odd(-2)
    '-2 is Even!'

    """
    #Define funtion to be tested
    if x % 2 == 0: #The conditional if 
        return "%d is Even!" % x # % x at the end is used to tell %d, a placeholder what it is and to sub
    return "%d is Odd!" % x

#def main(argv):  # Step 2
    print(t.even_or_odd(22)) # Loop 1 to the top
    print(t.even_or_odd(33)) # Loop 2 to the top 
    return 0

#if (__name__ == "__main__"): # Step 1
    status = main(sys.argv) 

doctest.testmod() #To run with embedded tests


**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 79.0

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.12049s

======================================================================
Inspecting script file sysargv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
#RUNNING SYS.ARGV OBJECTS
#############################
import sys
print("This is the name of the script:", sys.argv[0]) #filename is [0]
print("Number of arguments:", len(sys.argv))
print("The arguments are:", str(sys.argv))

#First list of the sys.argv is always filename 
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 77.0

Output (only first 500 characters): 


**********************************************************************
This is the name of the script: sysargv.py
Number of arguments: 1
The arguments are: ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.07989s

======================================================================
Inspecting script file tuple.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Practical Comprehensions using tuples
##################

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# 
# A nice example output is:
# 
# Latin name: Passerculus sandwichensis
# Common name: Savannah sparrow
# Mass: 18.7
# ... etc.

# Hints: use the "print" command! You can use list comprehensions!

sparrow=[b for b in birds[0]]
print ("Latin name:" + sparrow[0] )
print ("Common name:" + sparrow[1])
print ("Mass:" + str(sparrow[2])) #need to convert the mass into a string, or change plus sign into comma 

martin=[c for c in birds[1]]
print ("Latin name:" + martin[0] )
print ("Common name:" + martin[1])
print ("Mass:" + str(martin[2])) 

yellow=[d for d in birds[2]]
print ("Latin name:" + yellow[0] )
print ("Common name:" + yellow[1])
print ("Mass:" + str(yellow[2])) 

dark=[e for e in birds[3]]
print ("Latin name:" + dark[0] )
print ("Common name:" + dark[1])
print ("Mass:" + str(dark[2])) 

swallow=[f for f in birds[4]]
print ("Latin name:" + swallow[0] )
print ("Common name:" + swallow[1])
print ("Mass:" + str(swallow[2])) 
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 75.0

Output (only first 500 characters): 


**********************************************************************
Latin name:Passerculus sandwichensis
Common name:Savannah sparrow
Mass:18.7
Latin name:Delichon urbica
Common name:House martin
Mass:19
Latin name:Junco phaeonotus
Common name:Yellow-eyed junco
Mass:19.5
Latin name:Junco hyemalis
Common name:Dark-eyed junco
Mass:19.6
Latin name:Tachycineata bicolor
Common name:Tree swallow
Mass:20.2

**********************************************************************

Code ran without errors

Time consumed = 0.07739s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
#LOOPS AND CONDITIONALS COMBINED
#############################

for j in range(12): #0 to 11
    if j % 3 == 0: #modulo operator e.g 8%3=2 , if J%3=0, true in this case 
        print('hello') #prints 4 times cause 4 numbers in range(12) has module of 0

for j in range(15):
    if j % 5 == 3: 
        print('hello') 
    elif j % 4 == 3: #in this case if range(15), print hello, elif=for else if, if the first condition for if is false, it checks the condition of elif
        print('hello')

# line 6 has 3 answers (3,8,13), line 8 has 3 answers (3,7,11) so hello should be print 6 times 
# HOWEVER, only 5 hellos are printed because the first condition is met already for 3 so 8th line wont be printed again, therefore only 5

z = 0 #LOOP, starts off with z is 0
while z != 15: # != not equal to , true statement 
    print('hello') 
    z = z + 3 # sub 0 into z first, then next z is 3 and go back to line 14, loop restarts until reaches z=15

z = 12
while z < 100: # true if z is smaller than 100
    if z == 31: # only one number which is 31
        for k in range(7): # range 0 to 6
            print('hello') # hello is print out 7 times [0,1,2,3,4,5,6]
    elif z == 18: # if above statement is false (if), the go to elif statement , only one number which is 18
        print('hello') # hello is print out 1 time
    z = z + 1 # if non above is true just jump to a new loop with a new z and not print out hello 
    # final is 8 output of hello



**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 73.0

Output (only first 500 characters): 


**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.08089s

======================================================================
Inspecting script file basic_io1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# FILE INPUT
#############################
# Open a file for reading 
with open('../sandbox/test.txt', 'r') as f: #r = opens a file for reading, example of opening files with 'with'
# use "implicit" for loop:
# Command to print out the lines in to text, if the object is a file, python will cycle over lines
    for line in f: 
        print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0: #checks if the line is empty
        print(line)

f.close()



**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 71.0

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io1.py", line 6, in <module>
    with open('../sandbox/test.txt', 'r') as f: #r = opens a file for reading, example of opening files with 'with'
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
Inspecting script file basic_io2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# FILE INPUT
#############################
# Save the elements of a list to a file 
list_to_save = range(100)

f = open('../sandbox/testout.txt','w') # w tells to open a file for writing
for i in list_to_save: 
    f.write(str(i) + '\n') #add a new line at the end

f.close()

**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 69.0

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.07627s

======================================================================
Inspecting script file boilerplate.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#Author: cy221@ic.ac.uk
#Script: boilerplate2.sh
#Description: simple boilerplate for python3
#Arugments: none
#Date: Oct 2021

"""Description of this program or application. 
You can use several lines""" #Docstring

#Internal variables signalled by __, special variables reserved for python, don't mess with them 
_appname_= '[python3]'
_author_= 'Cherie Yu (cy221@ic.ac.uk)'
_version_= '3.9.7'
_license_= "License for this code/program"

## imports ##
import sys #module to interface our program with the operating system, always import something in a program

## constants ##

## functions ##
def main(argv): #defintions, start of a function, main means the main function, argv is the arguments from the bottom function
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": #adding this directs the python reader to set the special _name_ variable 
#to have a value called main. So the file will be usable as a script and an importable module (for usibility and packaging). 
#read my notes
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv) #argv = argument variable, an objected created using the sys module that contains the names of the argument variables in the current script
    sys.exit(status) #Way to terminate the program in an explicit manner
    #arguments from here is fed back to the main function




**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 69.0

Output (only first 500 characters): 


**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.07876s

======================================================================
Inspecting script file MyExampleScript.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# HOW TO WRITE A SCRIPT
#############################
def foo(x):
    x *= x # same as x = x*x
    print(x)

foo(2)
**********************************************************************

Testing MyExampleScript.py...

MyExampleScript.py is a Python script file;

checking for docstrings...

Found one or more functions, but completely missing docstrings
2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function

Current Points = 66.5

Output (only first 500 characters): 


**********************************************************************
4

**********************************************************************

Code ran without errors

Time consumed = 0.07801s

======================================================================
Inspecting script file lc1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
##################
#Practical Comprehensions
##################
#Practical list Comprehension from task 1c1.py

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )
#tupple

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

#List of Latin Names
species_names = [names[0]for names in birds] #List comprehension
print(species_names)

#List of common names
common_names = [common[1]for common in birds] #List comprehension
print(common_names)

#List of mean body massess
body_mass = [body[2]for body in birds]
print(body_mass)

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

#List of Latin Names
species_names= []
for names in birds: 
    species_names.append(names[0])
print(species_names)

#List of common names
common_names = []
for common in birds:
    common_names.append(common[1])
print(common_names)

#List of mean body massess
body_mass = []
for body in birds:
    body_mass.append(body[2])
print(body_mass)
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 64.5

Output (only first 500 characters): 


**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.07631s

======================================================================
Inspecting script file basic_csv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
#############################
# HANDLING CSV's
#############################
# To manipulate CSV files
import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f) 
    temp = [] #you make a empty list and set is as the object temp
    for row in csvread: 
        temp.append(tuple(row)) #changing temp list with tuple(list) of rows, you are locking the rows together as a immendible set
        print(row)

# write a file named bodymass.csv containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f) #open file f and make it as an object
        csvwrite = csv.writer(g) #writing a file g.csv and make it as an object
        for row in csvread: 
            print(row) 
            csvwrite.writerow([row[0], row[4]]) #write the rows in the objects in csvwrite aka g object

**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
2 pts deducted

Current Points = 62.5

Output (only first 500 characters): 


**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagascar', '0.814']
['Avahi_unicolor', 'Lemuriformes', 'Indridae', 'America', '0.83']
['Cheirogaleus_adipicaudatus', 'Lemuriformes', 'Che
**********************************************************************

Code ran without errors

Time consumed = 0.08197s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
import csv
import sys
import doctest

#write doctests to make sure that your is_an_oak function is working as expected (hint: >>> is_an_oak('Fagus sylvatica') should return False)
def is_an_oak(name):
    """Find whether name is an oak
    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('Pinus sylvestris')
    False

    >>> is_an_oak('quercus cerris')
    True

    >>> is_an_oak('Crataegus monogyna')
    False

    >>> is_an_oak('Quercuss cerris')
    True
    """
    return name.lower().startswith('quercus') #bug was here, spelling error 

def main(argv): 
    """writes a new csv file with just oak data"""
    """if it is an oak, print out string and write it in new csv file"""
    f = open('../data/TestOaksData.csv','r') #read the csv file
    g = open('../data/JustOaksData.csv','w') #write a new csv file
    taxa = csv.reader(f) # read f
    csvwrite = csv.writer(g) # write g
    oaks = set()
    for row in taxa: # in f file
        #import ipdb; ipdb.set_trace()
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])
        
    return 0
    
if (__name__ == "__main__"): 
    status = main(sys.argv) #read the main function

doctest.testmod()
#starts off with reading the entire script from the top, then hits line 27, and go back up to main function
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 62.5

Output (only first 500 characters): 


**********************************************************************
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.12087s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 62.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!