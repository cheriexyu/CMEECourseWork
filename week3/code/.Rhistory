if (i==10){
break
}
else{
cat("i equals", i, "\n")
i<-i+1 #Updates i
}
}
#Breaking out of loops, stop the loop when some condition is met
i <- 0 #Initialize i
while(i<5){ #while i is an positive infinity, storing numbers that can be divisible by 0
if (i==10){
break
}
else{
cat("i equals", i, "\n")
i<-i+1 #Updates i
}
}
#Breaking out of loops, stop the loop when some condition is met
i <- 0 #Initialize i
while(i<Inf){ #while i is an positive infinity, storing numbers that can be divisible by 0
if (i==10){
break
}
else{
cat("i equals", i, "\n")
i<-i+1 #Updates i
}
}
#Using next in control flow to next iteration of a loop
for (i in 1:10){
if ((i %% 2) == 0) #check if number is odd, %% modular division, if remainder is 0
next #pass to next iteration of loop
print(i)
}
# A boilerplate R script
MyFunction<-function(Arg1, Arg2){
print(MyFunction)
#Statements involving Arg1,Arg2:
print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) #prints Arg1's type
print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) #prints Arg2's type
return (c(Arg1, Arg2)) #this is optional, but very useful
}
MyFunction(1,2) #test the function
# A boilerplate R script
MyFunction<-function(Arg1, Arg2){
print(MyFunction)
#Statements involving Arg1,Arg2:
print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) #prints Arg1's type
print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) #prints Arg2's type
return (c(Arg1, Arg2)) #this is optional, but very useful
}
MyFunction(1,2) #test the function
#MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
source("boilerplate.R")
ls()
class(MyFunction)
#Functions with conditions
#Check if an integer is even
is.even<-function(n=2){  #write n is 2 if value is not defined
if(n%%2==0) #if the module remainder is 0, means its even
{
return(paste(n,'is even!')) #paste it is even
}
return(paste(n,'is odd!')) #if not paste it is odd
}
is.even(6)
#Check is a number is a power of 2
is.power2<-function(n=2){ #write = 2 if n is not defined
if (log2(n) %% 1==0) #if the module R is 0, that means it is the power of 2
{
return(paste(n,'is a power of 2!'))
}
return(paste(n,'is not a power of 2!'))
}
is.power2(4)
is.prime<-function(n){
if (n==0){ #if n is a 0
return(paste(n,'is a zero!'))
}
if (n==1){ #if n is 1
return(paste(n,'is just a unit!'))
}
ints<-2:(n-1) #
if (all(n%%ints!=0)){
return(paste(n,'is a prime!'))
}
return(paste(n,'is a composite!')) #if not any, prime 1 or 0
}
is.prime(3)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
TreeHeight(37,40)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
sink('output_tree.csv',append=TRUE)
cat(TreeData)
print(TreeData)
Output<-TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData$Added_Column <- Output
Output$Height
print(Output$Height)
print(Output$height)
print(height)
print(Treeheight(height))
print(TreeHeight(height))
#TreeHeight(37,40)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height<-TreeHeight(height)
Height<-TreeHeight$height
Height<-TreeHeight(height)
#TreeHeight(37,40)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
#TreeHeight(37,40)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
View(TreeData)
TreeData$Angle.degrees
TreeData
TreeData<-read.csv("../data/trees.csv",header=TRUE)
TreeData
View(TreeData)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
#TreeHeight(37,40)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData$Angle.degrees
#TreeHeight(37,40)
TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
#print(paste("Tree height is:", height))
return(height)
}
#TreeHeight(37,40)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
#TreeHeight(37,40)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
#print(paste("Tree height is:", height))
return(height)
}
#TreeHeight(37,40)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
sink('output_tree.csv',append=TRUE)
print(TreeData)
TreeData$Added_Column <- Height
#TreeHeight(37,40)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(TreeData)
TreeData["new_col"] <- Height
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(TreeData)
TreeData["new_col"] <- Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(TreeData)
TreeData["new_col"] <- Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(TreeData)
TreeData["new_col"] <- Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height
Height
TreeData<-read.csv("../data/trees.csv",header=TRUE)
head(TreeData)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(TreeData)
TreeData["new_col"] <- Height
Height
print(Height)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi/180 #Equation 1
height <- distance * tan(radians) #Main Equation
print(paste("Tree height is:", height))
return(height)
}
sink('output_tree.csv',append=TRUE)
Height = TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
sink('output_tree.csv',append=TRUE)
print(Height)
Height ã€Š- TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
Height<-TreeHeight(TreeData$Angle.degrees,TreeData$Distance.m)
print(Height)
Height
v1
length(Height)
yo <- length(Height)
head(TreeData)
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment<-function(popn,n){
pop_sample<-sample(popn, n, replace=FALSE) #sample() takes a sample of the specified size from the element x (popn),using either with or without replacement
return(mean(pop_sample)) #return the mean of that sample taken
}
## To run "num" iterations of the experiment using a For loop on a loop with preallocations:
loopy_sample3<-function(popn, n, num){
result3<-vector("list", num) #preallocate expected size
for(i in 1:num){
result3[[i]]<-myexperiment(popn, n)
}
return(result3)
}
#Generate population
set.seed(12345)
popn<-rnorm(1000) #Generate population
hist(popn)
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,n,num)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,n,num)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,n,num)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,n,num)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,n,num)))
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment<-function(popn,n){
pop_sample<-sample(popn, n, replace=FALSE) #sample() takes a sample of the specified size from the element x (popn),using either with or without replacement
return(mean(pop_sample)) #return the mean of that sample taken
}
##Calculate means using a FOR loop on a vector without preallocation:
#write the mean of n in the empty vector by concatenating and looping
loopy_sample1<-function(popn, n, num){
reult1<-vector() #Initialize empty vector of size 1
for(i in 1:num){ #between range 1 to num
result1<-c(result1,myexperiment(popn, n)) #concatenate vector,with the calculate mean function
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2<-function(popn, n, num){
result2<-vector(,num) #preallocate expected size
for(i in 1:num){
result2[i]<-myexperiment(popn,n) #calculate mean function of size n and set it as i and puts it into the vector
#then loops and continues on from i (1 to 2)
}
return(result2)
}
## To run "num" iterations of the experiment using a For loop on a loop with preallocations:
loopy_sample3<-function(popn, n, num){
result3<-vector("list", num) #preallocate expected size
for(i in 1:num){
result3[[i]]<-myexperiment(popn, n) #mean, put it as i and put it into the vector
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample<-function(popn, n,num){
result4<-lapply(1:num, function(i) myexperiment(popn, n)) #lapply num, with the function i
}  #function(i) does not mean anything, just a placeholder to tell to do that function to all from 1:num
## To run "num" iterations fo the experiment using vectorization with sapply:
sapply_sample<-function(popn, n, num){
result5<-sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
#Generate population
set.seed(12345)
popn<-rnorm(1000) #Generate population
hist(popn)
#Run and time the different functions
n<-100 #sample size for each experiment
num<-10000 #Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,n,num)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,n,num)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,n,num)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,n,num)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,n,num)))
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment<-function(popn,n){
pop_sample<-sample(popn, n, replace=FALSE) #sample() takes a sample of the specified size from the element x (popn),using either with or without replacement
return(mean(pop_sample)) #return the mean of that sample taken
}
##Calculate means using a FOR loop on a vector without preallocation:
#write the mean of n in the empty vector by concatenating and looping
loopy_sample1<-function(popn, n, num){
result1<-vector() #Initialize empty vector of size 1
for(i in 1:num){ #between range 1 to num
result1<-c(result1,myexperiment(popn, n)) #concatenate vector,with the calculate mean function
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2<-function(popn, n, num){
result2<-vector(,num) #preallocate expected size
for(i in 1:num){
result2[i]<-myexperiment(popn,n) #calculate mean function of size n and set it as i and puts it into the vector
#then loops and continues on from i (1 to 2)
}
return(result2)
}
## To run "num" iterations of the experiment using a For loop on a loop with preallocations:
loopy_sample3<-function(popn, n, num){
result3<-vector("list", num) #preallocate expected size
for(i in 1:num){
result3[[i]]<-myexperiment(popn, n) #mean, put it as i and put it into the vector
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample<-function(popn, n,num){
result4<-lapply(1:num, function(i) myexperiment(popn, n)) #lapply num, with the function i
}  #function(i) does not mean anything, just a placeholder to tell to do that function to all from 1:num
## To run "num" iterations fo the experiment using vectorization with sapply:
sapply_sample<-function(popn, n, num){
result5<-sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
#Generate population
set.seed(12345)
popn<-rnorm(1000) #Generate population
hist(popn)
#Run and time the different functions
n<-100 #sample size for each experiment
num<-10000 #Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,n,num)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,n,num)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,n,num)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,n,num)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,n,num)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,450)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,450)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,450)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,450)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,450)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,n)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,n)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,n)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,n)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,n)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,650)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,650)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,650)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,650)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,650)))
x<-1:20 #a vector
x
#Create a factor type variable (of the same length) defining groups
y<-factor(rep(letters[1:5], each=4))
y
#Add up the values in x within each subgroup defined by y
tapply(x,y,sum)
##USING BY
attach(iris)
iris
by(iris[,1:2], iris$Species, colMeans)
by(iris[,1:2], iris$Petal.Width, colMeans)
replicate(10,runif(5))
Ricker<-function(N0=1,r=1,k=10,generations=50) #r is intrinsic growth, k is carrying capacity
{
#Runs a simulation of the Ricker model
#Returns a vector of length generations
N<-rep(NA,generations) #creates a vector of NA
N[1]<-N0
for (t in 2:generations)
{
N[t]<-N[t-1]*exp(r*(1.0-(N[t-1]/K)))
}
return(N)
}
plot(Ricker(generations=10), type="l")
Ricker<-function(N0=1,r=1,K=10,generations=50) #r is intrinsic growth, k is carrying capacity
{
#Runs a simulation of the Ricker model
#Returns a vector of length generations
N<-rep(NA,generations) #creates a vector of NA
N[1]<-N0
for (t in 2:generations)
{
N[t]<-N[t-1]*exp(r*(1.0-(N[t-1]/K)))
}
return(N)
}
plot(Ricker(generations=10), type="l")
N <- matrix(NA, numyears, length(p0))
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N
print(N)
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{
N <- matrix(NA, numyears, length(p0))
return(N)
0 = runif(1000, .5, 1.5)
p0 = runif(1000, .5, 1.5)
p0
