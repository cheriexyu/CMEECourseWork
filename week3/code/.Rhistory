result2<-vector(,num) #preallocate expected size
for(i in 1:num){
result2[i]<-myexperiment(popn,n) #calculate mean function of size n and set it as i and puts it into the vector
#then loops and continues on from i (1 to 2)
}
return(result2)
}
## To run "num" iterations of the experiment using a For loop on a loop with preallocations:
loopy_sample3<-function(popn, n, num){
result3<-vector("list", num) #preallocate expected size
for(i in 1:num){
result3[[i]]<-myexperiment(popn, n) #mean, put it as i and put it into the vector
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample<-function(popn, n,num){
result4<-lapply(1:num, function(i) myexperiment(popn, n)) #lapply num, with the function i
}  #function(i) does not mean anything, just a placeholder to tell to do that function to all from 1:num
## To run "num" iterations fo the experiment using vectorization with sapply:
sapply_sample<-function(popn, n, num){
result5<-sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
#Generate population
set.seed(12345)
popn<-rnorm(1000) #Generate population
hist(popn)
#Run and time the different functions
n<-100 #sample size for each experiment
num<-10000 #Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,n,num)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,n,num)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,n,num)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,n,num)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,n,num)))
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment<-function(popn,n){
pop_sample<-sample(popn, n, replace=FALSE) #sample() takes a sample of the specified size from the element x (popn),using either with or without replacement
return(mean(pop_sample)) #return the mean of that sample taken
}
##Calculate means using a FOR loop on a vector without preallocation:
#write the mean of n in the empty vector by concatenating and looping
loopy_sample1<-function(popn, n, num){
result1<-vector() #Initialize empty vector of size 1
for(i in 1:num){ #between range 1 to num
result1<-c(result1,myexperiment(popn, n)) #concatenate vector,with the calculate mean function
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2<-function(popn, n, num){
result2<-vector(,num) #preallocate expected size
for(i in 1:num){
result2[i]<-myexperiment(popn,n) #calculate mean function of size n and set it as i and puts it into the vector
#then loops and continues on from i (1 to 2)
}
return(result2)
}
## To run "num" iterations of the experiment using a For loop on a loop with preallocations:
loopy_sample3<-function(popn, n, num){
result3<-vector("list", num) #preallocate expected size
for(i in 1:num){
result3[[i]]<-myexperiment(popn, n) #mean, put it as i and put it into the vector
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample<-function(popn, n,num){
result4<-lapply(1:num, function(i) myexperiment(popn, n)) #lapply num, with the function i
}  #function(i) does not mean anything, just a placeholder to tell to do that function to all from 1:num
## To run "num" iterations fo the experiment using vectorization with sapply:
sapply_sample<-function(popn, n, num){
result5<-sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
#Generate population
set.seed(12345)
popn<-rnorm(1000) #Generate population
hist(popn)
#Run and time the different functions
n<-100 #sample size for each experiment
num<-10000 #Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,n,num)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,n,num)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,n,num)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,n,num)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,n,num)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,450)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,450)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,450)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,450)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,450)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,n)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,n)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,n)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,n)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,n)))
print("Using loops without preallocation on a vector took:")
print(system.time(loopy_sample1(popn,1000,650)))
print("Using loops with preallocation on a vector took:")
print(system.time(loopy_sample2(popn,1000,650)))
print("Using loops with preallocation on a list took:")
print(system.time(loopy_sample3(popn,1000,650)))
print("Using the vectorized sapply function (on a list) took:")
print(system.time(sapply_sample(popn,1000,650)))
print("Using the vectorized lapply fuction (on a list) took:")
print(system.time(lapply_sample(popn,1000,650)))
x<-1:20 #a vector
x
#Create a factor type variable (of the same length) defining groups
y<-factor(rep(letters[1:5], each=4))
y
#Add up the values in x within each subgroup defined by y
tapply(x,y,sum)
##USING BY
attach(iris)
iris
by(iris[,1:2], iris$Species, colMeans)
by(iris[,1:2], iris$Petal.Width, colMeans)
replicate(10,runif(5))
Ricker<-function(N0=1,r=1,k=10,generations=50) #r is intrinsic growth, k is carrying capacity
{
#Runs a simulation of the Ricker model
#Returns a vector of length generations
N<-rep(NA,generations) #creates a vector of NA
N[1]<-N0
for (t in 2:generations)
{
N[t]<-N[t-1]*exp(r*(1.0-(N[t-1]/K)))
}
return(N)
}
plot(Ricker(generations=10), type="l")
Ricker<-function(N0=1,r=1,K=10,generations=50) #r is intrinsic growth, k is carrying capacity
{
#Runs a simulation of the Ricker model
#Returns a vector of length generations
N<-rep(NA,generations) #creates a vector of NA
N[1]<-N0
for (t in 2:generations)
{
N[t]<-N[t-1]*exp(r*(1.0-(N[t-1]/K)))
}
return(N)
}
plot(Ricker(generations=10), type="l")
N <- matrix(NA, numyears, length(p0))
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N
print(N)
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{
N <- matrix(NA, numyears, length(p0))
return(N)
0 = runif(1000, .5, 1.5)
p0 = runif(1000, .5, 1.5)
p0
load("~/Documents/CMEECourseWork/week3/data/KeyWestAnnualMeanTemperature.RData")
View(MyData)
View(MyData)
View(ats)
MyData<-as.matrix(read.csv("../data/PoundHillData.csv",header=FALSE))
class(MyData)
head(MyData)
MyData
MyMetaData<-read.csv("../data/PoundHillMetaData.csv",header=TRUE, sep=";")
class(MyMetaData)
heade(MyMetaData)
head(MyMetaData)
############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
############# Inspect the dataset ###############
head(MyData)
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- t(MyData)
head(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0 #
head(MyData)
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
#make a new data frame with
colnames(TempData) <- MyData[1,] # assign column names from original data
head(TempData)
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!, character should not be coverted to a factor = False
#make a new data frame and get rid of the first column (-1)
colnames(TempData) <- MyData[1,] # assign column names from original data so
head(TempData)
?melt #check out the melt function
?melt #check out the melt function
??melt #check out the melt function
reshape2
############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package
??melt #check out the melt function
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
MyWrangledData
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)
MyMetaData
MyData[MyData == ""] = 0
class(MyData)
MyData
MyData
class(MyData)
#####Opening as a data frame as needed by R for data analysis.
TempData<-as.data.frame(MyData[01,],stringsAsFactors = F)
head(TempData)
#####Opening as a data frame as needed by R for data analysis.
TempData<-as.data.frame(MyData[-1,],stringsAsFactors = F)
head(TempData)
colnames(TempData)<-MyData[1,]
head(TempData)
head(TempData)
#Convert data to long format
require(reshape2)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
head(MyWrangledData);tail(MyWrangledData)
#Convert each column into a factor
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
#Convert into a integer
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
install.packages(c("tidyverse"))
tidyverse_packages(include_self = TRUE)
tidyverse(include_self = TRUE)
tidyverse_packages(include_self = TRUE)
require("tidyverse")
#:: allow you to access a particular function from a package
tibble::as_tibble(MyWrangledData)
dplyr::filter(MyWrangledData,Count>100)
dplyr::glimpse(MyWrangledData)
dplyr::filter(MyWrangledData,Count>100)
N<-rep(NA,generations) #creates a vector of NA
Exponential<-function(N0=1,r=1,generations=10){
#Runs a simulation of exponential growth
#Returns a vector of length generations
N<-rep(NA,generations) #creates a vector of NA
N[1]<-N0
for(t in 2:generations){
N[t]<-N[t-1]*exp(r)
browser()
}
return(N)
}
plot(Exponential(), type="l", main="Exponential growth")
q
set.seed(1345)
popn<-rnorm(50)
hist(popn)
hist(popn)
doit<-function(x){
temp_x<-sample(x,replace=TRUE) #take a sample of x
if(length(unique(temp_x))>30) {#only take mean if sample was sufficent, more than 30
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calculate mean: too few unique values!")
}
}
#run the function on this population 15 times using vectorization(lapply)
lapply(1:15,function(i) doit(popn)) #function(i) is a placeholder
result<-lapply(1:15,function(i) try(doit(popn),FALSE))
class(result)
result
for (i in 1:15){
result[[i]]<-try(doit(popn, FALSE))
}
#Storing results manually in a loop
result<-vector("list",15) #preallocating a loop of 15
for (i in 1:15){
result[[i]]<-try(doit(popn, FALSE))
}
#Storing results manually in a loop
result<-vector("list",15) #preallocating a loop of 15
for (i in 1:15){
result[[i]]<-try(doit(popn), FALSE)
}
source("try.R")
source("try.R")
source("try.R")
result<-lapply(1:15,function(i) try(doit(popn),FALSE))
result<-vector("list",15) #preallocating a loop of 15
for (i in 1:15){
result[[i]]<-try(doit(popn), FALSE)
}
source("try.R")
source("try.R")
load("KeyWestAnnualMeanTemperature.Rdata",verbose=FALSE)
load("../data/KeyWestAnnualMeanTemperature.Rdata",verbose=FALSE)
temp<-load("../data/KeyWestAnnualMeanTemperature.Rdata",verbose=FALSE)
temp
View(ats)
View(MyData)
class(temp)
ls(temp)
ls(temp)
print(temp)
View(ats)
keywest<-load("../data/KeyWestAnnualMeanTemperature.Rdata")
ls(keywest)
ls(ats)
head(ats)
View(ats)
plot(keywest)
plot(ats)
load("../data/KeyWestAnnualMeanTemperature.Rdata")
head(ats)
plot(ats)
#Temperature in KeyWest for the 20th Century
class(ats)
summary(ats)
is.vector(ats)
data = data[['ats']]
data = data[['ats$Year']]
vector<-ats[,]
vector
is.vector(vector)
class(vector)
Year<-ats[1,]
Year
Year<-ats[,1]
Year
is.vector(Year) #is it a vector
Temp<-ats[,2]
Temp
is.vector(Temp)
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,x) #pre=allocated vector for correlation coefficent
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
for (i in 1:10000){
a[i] <- cor(Year,sample(Temp,replace=TRUE))
}
return(a)
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
for (i in 1:10000){
a[i] <- cor(Year,sample(Temp,replace=TRUE))
}
print(a)
hist(a)
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
plot(ats)
cor(Year,Temp)
approx<-cor(Year,Temp)
approx
#histagram of correlation coefficents
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
for (i in 1:10000){
a[i] <- cor(Year,sample(Temp,replace=TRUE))
}
print(a)
#histagram of correlation coefficents
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
a[i] <- cor(sample(Year,replace=TRUE),Temp)
for (i in 1:10000){
a[i] <- cor(sample(Year,replace=TRUE),Temp)
}
print(a)
#histagram of correlation coefficents
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
for (i in 1:10000){
a[i] <- cor(Year,sample(Temp,replace=TRUE))
}
print(a)
#histagram of correlation coefficents
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
plot(ats)
load("../data/KeyWestAnnualMeanTemperature.Rdata") #Temperature in KeyWest for the 20th Century
head(ats)
plot(ats)
approx<-cor(Year,Temp) #correlation coefficent
approx
class(ats) #Dataframe
#Save it as a vector
keywest <- vect
is.vector(Year) #is it a vector
Year<-ats[,1]
Year
is.vector(Year) #Check it is a vector
Temp<-ats[,2]
Temp
is.vector(Temp) #Check it is a vector
#Shuffle the temp then calculate a correlation coefficent, repeat by 10000
a <- rep(NA,10000) #pre=allocated vector for correlation coefficent
for (i in 1:10000){
a[i] <- cor(Year,sample(Temp,replace=TRUE))
}
print(a)
#histagram of correlation coefficents
hist(a, xlab="Correlation Coefficent", ylab="Frequency", main="Histagram of Matrix")
dplyr::slice(MyWrangledData,10:15)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
MyData<-as.matrix(read.csv("../data/PoundHillData.csv",header=FALSE))
class(MyData)
MyData
MyMetaData<-read.csv("../data/PoundHillMetaData.csv",header=TRUE, sep=";")
class(MyMetaData)
head(MyMetaData)
#Refer to DataWrang.R for data wrangling
#####Opening as a data frame as needed by R for data analysis.
#Creating a dataframe while excluding the first matrix row as its the column names
TempData<-as.data.frame(MyData[-1,],stringsAsFactors = F)
# Strings as factors is needed because we don't want R to convert columns to factors
head(TempData)
colnames(TempData)<-MyData[1,]
head(TempData)
#Delete row names, I don't like them
rownames(TempData)<-NULL
head(TempData)
#Convert data to long format
require(reshape2)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
head(MyWrangledData);tail(MyWrangledData) #show the head and tail (5 rows each)
#Convert each column into a factor
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
#Convert into a integer
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
install.packages(c("tidyverse"))
require("tidyverse")
tidyverse_packages(include_self = TRUE)
# "::" allow you to access a particular function from a package
tibble::as_tibble(MyWrangledData)#Data frames that are lazy surly and do less
dplyr::glimpse(MyWrangledData) #Change the dataframe to like strings but nicer, to see all the data like print
dplyr::filter(MyWrangledData,Count>100) #subsetting data to only showing rows that satisfy your condition
#here is more than 100
dplyr::slice(MyWrangledData,10:15)
#Opening a matrix
MyData<-as.matrix(read.csv("../data/PoundHillData.csv",header=FALSE))
class(MyData)
MyData
MyMetaData<-read.csv("../data/PoundHillMetaData.csv",header=TRUE, sep=";")
class(MyMetaData)
head(MyMetaData)
#####Opening as a data frame as needed by R for data analysis.
#Creating a dataframe while excluding the first matrix row as its the column names
TempData<-as.data.frame(MyData[-1,],stringsAsFactors = F)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
# Strings as factors is needed because we don't want R to convert columns to factors
head(TempData)
colnames(TempData)<-MyData[1,]
head(TempData)
#Delete row names, I don't like them
rownames(TempData)<-NULL
head(TempData)
#Convert data to long format
require(reshape2)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
head(MyWrangledData);tail(MyWrangledData) #show the head and tail (5 rows each)
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
#####Opening as a data frame as needed by R for data analysis.
#Creating a dataframe while excluding the first matrix row as its the column names
TempData<-as.data.frame(MyData[-1,],stringsAsFactors = F)
# Strings as factors is needed because we don't want R to convert columns to factors
head(TempData)
colnames(TempData)<-MyData[1,]
#Convert data to long format
require(reshape2)
MyWrangledData<-melt(TempData, id=c("Cultivation","Block","Plot","Quadrat"), variable.name="Species", value.name="Count")
head(TempData)
